<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hurricane Season Animator</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        /* Custom Scrollbar for the timeline */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
        
        /* Map Marker Square Style */
        .storm-marker {
            transition: background-color 0.1s linear;
            box-shadow: 0 0 8px rgba(0,0,0,0.8);
            cursor: pointer;
        }
        .storm-marker:hover {
            border-color: #3b82f6 !important; /* Blue border on hover */
            border-width: 2px !important;
        }
        
        /* Label styling */
        .storm-label {
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 4px;
            white-space: nowrap;
            box-shadow: none;
        }
        .leaflet-tooltip-left:before, .leaflet-tooltip-right:before {
            border: none;
        }

        /* Toggle Switch */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #68D391;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #68D391;
        }

        /* Draggable Panel Styles */
        .draggable-panel {
            position: fixed;
            min-width: 300px; /* Enforce horizontal format */
            box-sizing: border-box;
            user-select: none;
            touch-action: none; /* Crucial for touch dragging */
            cursor: move; /* Set default cursor to move for the whole panel */
        }
        /* Specific handle for controls panel, which still has one */
        #controlsPanel .drag-handle {
            cursor: move; /* Indicates draggability */
        }
        
        /* Hidden state for controls */
        .controls-hidden #controlsContent {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            overflow: hidden;
        }
        .controls-hidden .drag-handle button svg {
             transform: rotate(180deg); /* Flip arrow up when hidden */
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen flex flex-col overflow-hidden">

    <div class="bg-gray-800 p-4 shadow-lg z-20 flex flex-wrap justify-between items-center gap-4">
        <div class="flex items-center gap-4">
            <h1 class="text-xl font-bold tracking-wider text-blue-400">HURRICANE<span class="text-white">VISUALIZER</span></h1>
            
            <div class="relative">
                <input type="file" id="fileInput" accept=".json" class="hidden" />
                <label for="fileInput" class="cursor-pointer bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded text-sm font-semibold transition">
                    Upload JSON
                </label>
            </div>
            <div class="flex flex-col">
                <span id="fileNameDisplay" class="text-xs text-gray-400 italic">No file loaded</span>
                <span id="trackingStatus" class="text-xs text-green-400 font-mono hidden">Tracking: None</span>
                <div class="text-xs text-gray-400 font-mono mt-1" id="stormCount">Active Storms: 0</div>
				<div class="text-xs text-gray-400 font-mono mt-1">Made by: PGFLIMSXD/handhule90/nlexsctex. Discord: nlexsctex</div>
            </div>
        </div>

        <div class="flex items-center gap-6">
            <div class="flex items-center gap-2">
                <span class="text-xs font-semibold uppercase text-gray-400">Auto-Focus New Storms</span>
                <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                    <input type="checkbox" name="toggle" id="autoFocusToggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                    <label for="autoFocusToggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></label>
                </div>
            </div>

            <div class="flex gap-2 text-xs font-mono hidden md:flex">
                <div class="flex items-center gap-1"><div class="w-3 h-3 bg-blue-600 border border-white"></div> TD</div>
                <div class="flex items-center gap-1"><div class="w-3 h-3 bg-green-500 border border-white"></div> TS</div>
                <div class="flex items-center gap-1"><div class="w-3 h-3 bg-yellow-400 border border-white"></div> C1</div>
                <div class="flex items-center gap-1"><div class="w-3 h-3 bg-orange-400 border border-white"></div> C2</div>
                <div class="flex items-center gap-1"><div class="w-3 h-3 bg-orange-600 border border-white"></div> C3</div>
                <div class="flex items-center gap-1"><div class="w-3 h-3 bg-red-600 border border-white"></div> C4</div>
                <div class="flex items-center gap-1"><div class="w-3 h-3 bg-pink-500 border border-white"></div> C5</div>
            </div>
        </div>
    </div>

    <div id="map" class="flex-grow bg-black z-10"></div>

    <div id="datePanel" class="draggable-panel p-4 bg-gray-800 rounded-lg shadow-2xl z-40 border border-gray-700" 
         style="left: 50px; bottom: 30px;">
        <div class="flex flex-col">
            <span class="text-xs text-gray-400 uppercase tracking-widest">Current Time</span>
            <span id="dateDisplay" class="text-xl font-mono font-bold text-blue-300">--:-- UTC, -- --- ----</span>
            </div>
    </div>

    <div id="controlsPanel" class="draggable-panel p-4 bg-gray-800 rounded-lg shadow-2xl z-40 border border-gray-700" 
         style="right: 50px; bottom: 30px;">
        <div class="drag-handle w-full flex justify-between items-center cursor-move text-gray-400 mb-3 p-1 rounded hover:bg-gray-700 transition">
            <span class="text-xs font-semibold uppercase tracking-wider">Playback Controls</span>
            <button id="hideControlsBtn" class="p-1 rounded hover:bg-gray-700 text-white transition transform duration-300">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
                </svg>
            </button>
        </div>
        <div id="controlsContent" class="transition-all duration-300 max-h-40 overflow-hidden pt-2 border-t border-gray-700">
            <div class="flex items-center justify-between">
                <button id="playPauseBtn" class="w-10 h-10 flex-shrink-0 flex items-center justify-center bg-white text-gray-900 rounded-full hover:bg-gray-200 transition font-bold">
                    ▶
                </button>
                <div class="flex-grow ml-4">
                    <input type="range" id="timeline" min="0" max="100" value="0" class="w-full" disabled>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const mapConfig = {
            center: [20, -90], 
            zoom: 3,
            minZoom: 2,
            maxZoom: 10
        };

        const colors = {
            td: '#2563eb', // Blue
            ts: '#22c55e', // Green
            c1: '#facc15', // Yellow
            c2: '#fb923c', // Orange
            c3: '#ea580c', // Reddish Orange
            c4: '#dc2626', // Red
            c5: '#ec4899'  // Pink
        };

        let map;
        let stormsData = [];
        let startTime = 0;
        let endTime = 0;
        let currentTime = 0;
        let isPlaying = false;
        let lastFrameTime = 0;
        const stormLayers = {}; 
        
        // Tracking State
        let currentlyTrackedStorm = null; // Name of storm camera is locked on
        let previouslyActiveStorms = new Set(); // To detect new formations
        let autoFocusEnabled = false;

        // --- Time Configuration ---
        const SIM_MS_PER_DAY = 86400000;
        const REAL_MS_PER_DAY = 5000;
        const SPEED_FACTOR = SIM_MS_PER_DAY / REAL_MS_PER_DAY; 

        // --- Draggable Panel Logic ---
        // MODIFIED: makeDraggable now takes an optional handleSelector
        function makeDraggable(elementId, handleSelector = null) {
            const element = document.getElementById(elementId);
            // If a handle selector is provided, use the handle, otherwise use the element itself
            const handle = handleSelector ? element.querySelector(handleSelector) : element;
            
            let isDragging = false;
            let currentX;
            let currentY;
            let initialX;
            let initialY;
            let xOffset = 0;
            let yOffset = 0;

            if (!handle) return; // Must have a target

            const dragStart = (e) => {
                e = e.touches ? e.touches[0] : e;
                
                // Get the current translation values if they exist
                const style = window.getComputedStyle(element);
                const matrix = new DOMMatrixReadOnly(style.transform);
                xOffset = matrix.m41;
                yOffset = matrix.m42;

                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
                
                isDragging = true;
                element.style.cursor = 'grabbing';
                element.classList.add('shadow-outline');
            }

            const dragEnd = () => {
                isDragging = false;
                element.style.cursor = 'move';
                element.classList.remove('shadow-outline');
            }

            const drag = (e) => {
                if (isDragging) {
                    e.preventDefault();
                    e = e.touches ? e.touches[0] : e;
                    
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    // Apply translation
                    element.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
                }
            }

            // Mouse events
            handle.addEventListener('mousedown', dragStart);
            document.addEventListener('mouseup', dragEnd);
            document.addEventListener('mousemove', drag);

            // Touch events for mobile responsiveness
            handle.addEventListener('touchstart', dragStart, { passive: false });
            document.addEventListener('touchend', dragEnd);
            document.addEventListener('touchmove', drag, { passive: false });
        }

        // --- Initialization ---
        function initMap() {
            map = L.map('map', {
                center: mapConfig.center,
                zoom: mapConfig.zoom,
                worldCopyJump: true,
                attributionControl: false,
                zoomControl: false 
            });
            
            L.control.zoom({ position: 'topright' }).addTo(map);

            // NASA GIBS Blue Marble Layer
            L.tileLayer('https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/BlueMarble_ShadedRelief_Bathymetry/default//GoogleMapsCompatible_Level8/{z}/{y}/{x}.jpg', {
                attribution: 'NASA GIBS',
                maxZoom: 8
            }).addTo(map);

            // Break tracking if user manually drags map
            map.on('dragstart', () => {
                if (currentlyTrackedStorm) {
                    stopTracking();
                }
            });
        }

        // --- Toggle Logic ---
        document.getElementById('autoFocusToggle').addEventListener('change', (e) => {
            autoFocusEnabled = e.target.checked;
        });

        document.getElementById('hideControlsBtn').addEventListener('click', () => {
            const panel = document.getElementById('controlsPanel');
            panel.classList.toggle('controls-hidden');
            // Stop playing if controls are hidden
            if (panel.classList.contains('controls-hidden') && isPlaying) {
                 isPlaying = false;
                 document.getElementById('playPauseBtn').textContent = '▶';
            }
        });

        function startTracking(stormName) {
            currentlyTrackedStorm = stormName;
            const statusEl = document.getElementById('trackingStatus');
            statusEl.textContent = `Tracking: ${stormName}`;
            statusEl.classList.remove('hidden');
        }

        function stopTracking() {
            currentlyTrackedStorm = null;
            const statusEl = document.getElementById('trackingStatus');
            statusEl.textContent = `Tracking: None`;
            statusEl.classList.add('hidden');
        }

        // --- Helpers ---
        function getCategoryColor(knots) {
            if (typeof knots === 'string') {
                knots = parseInt(knots.replace(/[^0-9]/g, ''), 10);
            }
            if (isNaN(knots)) return colors.td;
            if (knots >= 137) return colors.c5;
            if (knots >= 113) return colors.c4;
            if (knots >= 96) return colors.c3;
            if (knots >= 83) return colors.c2;
            if (knots >= 64) return colors.c1;
            if (knots >= 34) return colors.ts;
            return colors.td;
        }

        function formatDate(timestamp) {
            const date = new Date(timestamp);
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            const month = monthNames[date.getUTCMonth()];
            const year = date.getUTCFullYear();
            return `${hours}:${minutes} UTC, ${day} ${month} ${year}`;
        }

        function normalizeLng(lng) {
            while (lng > 180) lng -= 360;
            while (lng < -180) lng += 360;
            return lng;
        }

        // --- Data Parsing ---
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('fileNameDisplay').textContent = file.name;
            const reader = new FileReader();
            
            reader.onload = function(event) {
                try {
                    const rawData = JSON.parse(event.target.result);
                    processData(rawData);
                } catch (err) {
                    // Using a custom message box instead of alert()
                    const messageBox = document.createElement('div');
                    messageBox.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-700 text-white p-6 rounded-lg shadow-2xl z-[9999]';
                    messageBox.innerHTML = `<strong>Error Parsing JSON:</strong> ${err.message}`;
                    document.body.appendChild(messageBox);
                    setTimeout(() => messageBox.remove(), 3000);
                }
            };
            reader.readAsText(file);
        });

        function processData(data) {
            stormsData = data;
            
            let minT = Infinity;
            let maxT = -Infinity;

            stormsData.forEach(storm => {
                storm.path.forEach(point => {
                    const tStr = point.time.replace(' ', 'T') + ':00Z';
                    point.timestamp = new Date(tStr).getTime();
                    
                    if (point.timestamp < minT) minT = point.timestamp;
                    if (point.timestamp > maxT) maxT = point.timestamp;

                    if (typeof point.speed === 'string') {
                        point.speedVal = parseInt(point.speed.replace(/[^0-9]/g, ''), 10) || 0;
                    } else {
                        point.speedVal = point.speed;
                    }
                });
                storm.path.sort((a, b) => a.timestamp - b.timestamp);
            });

            if (minT === Infinity) {
                // Using a custom message box instead of alert()
                const messageBox = document.createElement('div');
                messageBox.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-700 text-white p-6 rounded-lg shadow-2xl z-[9999]';
                messageBox.innerHTML = '<strong>Data Error:</strong> No valid time data found in the file.';
                document.body.appendChild(messageBox);
                setTimeout(() => messageBox.remove(), 3000);
                return;
            }

            startTime = minT;
            endTime = maxT;
            currentTime = startTime;

            const timeline = document.getElementById('timeline');
            timeline.min = startTime;
            timeline.max = endTime;
            timeline.value = startTime;
            timeline.disabled = false;

            // Reset tracking
            stopTracking();
            previouslyActiveStorms.clear();

            updateDisplay();
        }

        // --- Animation Logic ---
        function updateDisplay() {
            document.getElementById('dateDisplay').textContent = formatDate(currentTime);
            document.getElementById('timeline').value = currentTime;

            let activeCount = 0;
            let currentActiveStorms = new Set();
            let trackPosition = null;

            stormsData.forEach(storm => {
                const isActive = storm.path.length > 0 && 
                                 currentTime >= storm.path[0].timestamp && 
                                 currentTime <= storm.path[storm.path.length - 1].timestamp;

                if (isActive) {
                    activeCount++;
                    currentActiveStorms.add(storm.name);
                    
                    // Render storm and get its current position
                    const pos = renderStorm(storm);
                    
                    // Check for new formation logic
                    if (autoFocusEnabled && !previouslyActiveStorms.has(storm.name)) {
                        // New storm formed!
                        startTracking(storm.name);
                        // Fly to it initially for effect
                        if (pos) map.flyTo(pos, 6, { duration: 1.5 });
                    }

                    // If this is the tracked storm, capture position
                    if (currentlyTrackedStorm === storm.name && pos) {
                        trackPosition = pos;
                    }

                } else {
                    removeStorm(storm);
                    // If tracked storm dissipates
                    if (currentlyTrackedStorm === storm.name) {
                        stopTracking();
                    }
                }
            });

            // Update state for next frame
            previouslyActiveStorms = currentActiveStorms;
            document.getElementById('stormCount').textContent = `Active Storms: ${activeCount}`;

            // Apply camera tracking if active
            if (trackPosition) {
                // Use panTo for smooth frame-by-frame following
                map.panTo(trackPosition, { animate: false });
            }
        }

        function renderStorm(storm) {
            let idx = -1;
            for (let i = 0; i < storm.path.length - 1; i++) {
                if (currentTime >= storm.path[i].timestamp && currentTime <= storm.path[i+1].timestamp) {
                    idx = i;
                    break;
                }
            }

            if (idx === -1) return null; 

            const p1 = storm.path[idx];
            const p2 = storm.path[idx+1];

            const range = p2.timestamp - p1.timestamp;
            const progress = (currentTime - p1.timestamp) / range;

            let lng1 = normalizeLng(p1.long);
            let lng2 = normalizeLng(p2.long);
            
            if (Math.abs(lng2 - lng1) > 180) {
                if (lng2 > lng1) lng1 += 360;
                else lng2 += 360;
            }

            const curLat = p1.lat + (p2.lat - p1.lat) * progress;
            const curLng = lng1 + (lng2 - lng1) * progress;
            
            const curSpeed = p1.speedVal + (p2.speedVal - p1.speedVal) * progress;
            const color = getCategoryColor(curSpeed);
            const latLng = [curLat, normalizeLng(curLng)];

            // Create or Update Marker
            if (!stormLayers[storm.name]) {
                const iconHtml = `<div class="storm-marker" style="
                        width: 14px; 
                        height: 14px; 
                        background-color: ${color}; 
                        border: 1px solid white;"></div>`;

                const icon = L.divIcon({
                    className: 'custom-div-icon',
                    html: iconHtml,
                    iconSize: [14, 14],
                    iconAnchor: [7, 7]
                });

                const marker = L.marker(latLng, {icon: icon}).addTo(map);
                
                // Tooltip
                marker.bindTooltip(storm.name, {
                    permanent: true, 
                    direction: 'right',
                    className: 'storm-label',
                    offset: [10, 0]
                });

                // Click event for manual tracking
                marker.on('click', () => {
                    startTracking(storm.name);
                    map.flyTo(latLng, 6); // Zoom in on click
                });

                const trail = L.polyline([], {
                    color: 'rgba(255,255,255,0.4)',
                    weight: 1
                }).addTo(map);

                stormLayers[storm.name] = { marker, trail, lastColor: color };
            } else {
                const layer = stormLayers[storm.name];
                layer.marker.setLatLng(latLng);
                
                const newColor = getCategoryColor(curSpeed);
                if (layer.lastColor !== newColor) {
                     const iconHtml = `<div class="storm-marker" style="
                        width: 14px; 
                        height: 14px; 
                        background-color: ${newColor}; 
                        border: 1px solid white;"></div>`;
                    
                    layer.marker.setIcon(L.divIcon({
                        className: 'custom-div-icon',
                        html: iconHtml,
                        iconSize: [14, 14],
                        iconAnchor: [7, 7]
                    }));
                    layer.lastColor = newColor;
                }

                // Trail update
                const trailPoints = [];
                for(let i=0; i<=idx; i++) {
                    trailPoints.push([storm.path[i].lat, normalizeLng(storm.path[i].long)]);
                }
                trailPoints.push(latLng);
                layer.trail.setLatLngs(trailPoints);
            }

            return latLng;
        }

        function removeStorm(storm) {
            if (stormLayers[storm.name]) {
                map.removeLayer(stormLayers[storm.name].marker);
                map.removeLayer(stormLayers[storm.name].trail);
                delete stormLayers[storm.name];
            }
        }

        // --- Controls Logic ---
        const playBtn = document.getElementById('playPauseBtn');
        const timelineInput = document.getElementById('timeline');

        playBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '||' : '▶';
            if (isPlaying) {
                lastFrameTime = performance.now();
                requestAnimationFrame(animate);
            }
        });

        timelineInput.addEventListener('input', (e) => {
            currentTime = parseInt(e.target.value);
            if (!isPlaying) {
                updateDisplay();
            }
        });

        timelineInput.addEventListener('mousedown', () => {
            if (isPlaying) isPlaying = false; 
        });
        
        timelineInput.addEventListener('mouseup', () => {
            if (playBtn.textContent === '||') {
                isPlaying = true;
                lastFrameTime = performance.now();
                requestAnimationFrame(animate);
            }
        });

        function animate(now) {
            if (!isPlaying) return;

            const dt = now - lastFrameTime;
            lastFrameTime = now;

            const step = dt * SPEED_FACTOR;
            currentTime += step;

            if (currentTime >= endTime) {
                currentTime = endTime;
                isPlaying = false;
                playBtn.textContent = '▶';
                updateDisplay();
                return;
            }

            updateDisplay();
            requestAnimationFrame(animate);
        }

        // --- Startup ---
        window.onload = function() {
            initMap();
            // MODIFIED: 'datePanel' now uses the element itself as the drag handle (handleSelector=null)
            makeDraggable('datePanel');
            // 'controlsPanel' still uses the '.drag-handle' selector
            makeDraggable('controlsPanel', '.drag-handle');
        }

    </script>
</body>
</html>